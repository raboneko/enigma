/* utils.c generated by valac 0.56.3, the Vala compiler
 * generated from utils.vala, do not modify */

/*
* Copyright (c) 2022 Fyra Labs
*
* This program is free software; you can redistribute it and/or
* modify it under the terms of the GNU General Public
* License as published by the Free Software Foundation; either
* version 3 of the License, or (at your option) any later version.
*
* This program is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
* General Public License for more details.
*
* You should have received a copy of the GNU General Public
* License along with this program; if not, write to the
* Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
* Boston, MA 02110-1301 USA
*
*/

#include <libhelium-1.h>
#include <glib-object.h>
#include <gio/gio.h>
#include <gtk/gtk.h>
#include <glib.h>
#include <glib/gi18n-lib.h>

#if !defined(VALA_EXTERN)
#if defined(_MSC_VER)
#define VALA_EXTERN __declspec(dllexport) extern
#elif __GNUC__ >= 4
#define VALA_EXTERN __attribute__((visibility("default"))) extern
#else
#define VALA_EXTERN extern
#endif
#endif

#define ENIGMA_TYPE_MAIN_WINDOW (enigma_main_window_get_type ())
#define ENIGMA_MAIN_WINDOW(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), ENIGMA_TYPE_MAIN_WINDOW, EnigmaMainWindow))
#define ENIGMA_MAIN_WINDOW_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), ENIGMA_TYPE_MAIN_WINDOW, EnigmaMainWindowClass))
#define ENIGMA_IS_MAIN_WINDOW(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), ENIGMA_TYPE_MAIN_WINDOW))
#define ENIGMA_IS_MAIN_WINDOW_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), ENIGMA_TYPE_MAIN_WINDOW))
#define ENIGMA_MAIN_WINDOW_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), ENIGMA_TYPE_MAIN_WINDOW, EnigmaMainWindowClass))

typedef struct _EnigmaMainWindow EnigmaMainWindow;
typedef struct _EnigmaMainWindowClass EnigmaMainWindowClass;
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
typedef struct _EnigmaUtilsDisplayOpenDialogData EnigmaUtilsDisplayOpenDialogData;
typedef struct _EnigmaUtilsDisplaySaveDialogData EnigmaUtilsDisplaySaveDialogData;
typedef struct _Block2Data Block2Data;
typedef struct _EnigmaUtilsRunDialogAsyncData EnigmaUtilsRunDialogAsyncData;

struct _EnigmaUtilsDisplayOpenDialogData {
	int _state_;
	GObject* _source_object_;
	GAsyncResult* _res_;
	GTask* _async_result;
	GFile* result;
	GtkFileChooserNative* dialog;
	EnigmaMainWindow* _tmp0_;
	GtkFileChooserNative* _tmp1_;
	GtkFileChooserNative* _tmp2_;
	EnigmaMainWindow* _tmp3_;
	GtkFileFilter* filter1;
	GtkFileFilter* _tmp4_;
	GtkFileFilter* _tmp5_;
	GtkFileFilter* _tmp6_;
	GtkFileChooserNative* _tmp7_;
	GtkFileFilter* _tmp8_;
	GtkFileFilter* filter;
	GtkFileFilter* _tmp9_;
	GtkFileFilter* _tmp10_;
	GtkFileFilter* _tmp11_;
	GtkFileChooserNative* _tmp12_;
	GtkFileFilter* _tmp13_;
	GtkResponseType response;
	GtkFileChooserNative* _tmp14_;
	GtkFileChooserNative* _tmp15_;
	GFile* _tmp16_;
};

struct _EnigmaUtilsDisplaySaveDialogData {
	int _state_;
	GObject* _source_object_;
	GAsyncResult* _res_;
	GTask* _async_result;
	GFile* result;
	GtkFileChooserNative* dialog;
	EnigmaMainWindow* _tmp0_;
	GtkFileChooserNative* _tmp1_;
	GtkFileChooserNative* _tmp2_;
	EnigmaMainWindow* _tmp3_;
	GtkFileFilter* filter1;
	GtkFileFilter* _tmp4_;
	GtkFileFilter* _tmp5_;
	GtkFileFilter* _tmp6_;
	GtkFileChooserNative* _tmp7_;
	GtkFileFilter* _tmp8_;
	GtkFileFilter* filter;
	GtkFileFilter* _tmp9_;
	GtkFileFilter* _tmp10_;
	GtkFileFilter* _tmp11_;
	GtkFileChooserNative* _tmp12_;
	GtkFileFilter* _tmp13_;
	GtkResponseType response;
	GtkFileChooserNative* _tmp14_;
	GtkFileChooserNative* _tmp15_;
	GFile* _tmp16_;
};

struct _Block2Data {
	int _ref_count_;
	GtkResponseType response;
	gpointer _async_data_;
};

struct _EnigmaUtilsRunDialogAsyncData {
	int _state_;
	GObject* _source_object_;
	GAsyncResult* _res_;
	GTask* _async_result;
	GtkFileChooserNative* dialog;
	GtkResponseType result;
	Block2Data* _data2_;
};

VALA_EXTERN EnigmaMainWindow* enigma_utils_win;
EnigmaMainWindow* enigma_utils_win = NULL;

VALA_EXTERN GType enigma_main_window_get_type (void) G_GNUC_CONST ;
G_DEFINE_AUTOPTR_CLEANUP_FUNC (EnigmaMainWindow, g_object_unref)
static void enigma_utils_display_open_dialog_data_free (gpointer _data);
VALA_EXTERN void enigma_utils_display_open_dialog (GAsyncReadyCallback _callback_,
                                       gpointer _user_data_);
VALA_EXTERN GFile* enigma_utils_display_open_dialog_finish (GAsyncResult* _res_);
static gboolean enigma_utils_display_open_dialog_co (EnigmaUtilsDisplayOpenDialogData* _data_);
VALA_EXTERN void enigma_utils_run_dialog_async (GtkFileChooserNative* dialog,
                                    GAsyncReadyCallback _callback_,
                                    gpointer _user_data_);
VALA_EXTERN GtkResponseType enigma_utils_run_dialog_finish (GAsyncResult* _res_);
static void enigma_utils_display_open_dialog_ready (GObject* source_object,
                                             GAsyncResult* _res_,
                                             gpointer _user_data_);
static void enigma_utils_display_save_dialog_data_free (gpointer _data);
VALA_EXTERN void enigma_utils_display_save_dialog (GAsyncReadyCallback _callback_,
                                       gpointer _user_data_);
VALA_EXTERN GFile* enigma_utils_display_save_dialog_finish (GAsyncResult* _res_);
static gboolean enigma_utils_display_save_dialog_co (EnigmaUtilsDisplaySaveDialogData* _data_);
static void enigma_utils_display_save_dialog_ready (GObject* source_object,
                                             GAsyncResult* _res_,
                                             gpointer _user_data_);
static void enigma_utils_run_dialog_async_data_free (gpointer _data);
static gboolean enigma_utils_run_dialog_async_co (EnigmaUtilsRunDialogAsyncData* _data_);
static Block2Data* block2_data_ref (Block2Data* _data2_);
static void block2_data_unref (void * _userdata_);
static void __lambda8_ (Block2Data* _data2_,
                 gint r);
static void ___lambda8__gtk_native_dialog_response (GtkNativeDialog* _sender,
                                             gint response_id,
                                             gpointer self);

static void
enigma_utils_display_open_dialog_data_free (gpointer _data)
{
	EnigmaUtilsDisplayOpenDialogData* _data_;
	_data_ = _data;
	_g_object_unref0 (_data_->result);
	g_slice_free (EnigmaUtilsDisplayOpenDialogData, _data_);
}

void
enigma_utils_display_open_dialog (GAsyncReadyCallback _callback_,
                                  gpointer _user_data_)
{
	EnigmaUtilsDisplayOpenDialogData* _data_;
	_data_ = g_slice_new0 (EnigmaUtilsDisplayOpenDialogData);
	_data_->_async_result = g_task_new (NULL, NULL, _callback_, _user_data_);
	g_task_set_task_data (_data_->_async_result, _data_, enigma_utils_display_open_dialog_data_free);
	enigma_utils_display_open_dialog_co (_data_);
}

GFile*
enigma_utils_display_open_dialog_finish (GAsyncResult* _res_)
{
	GFile* result;
	EnigmaUtilsDisplayOpenDialogData* _data_;
	_data_ = g_task_propagate_pointer (G_TASK (_res_), NULL);
	result = _data_->result;
	_data_->result = NULL;
	return result;
}

static void
enigma_utils_display_open_dialog_ready (GObject* source_object,
                                        GAsyncResult* _res_,
                                        gpointer _user_data_)
{
	EnigmaUtilsDisplayOpenDialogData* _data_;
#line 34 "../src/utils.vala"
	_data_ = _user_data_;
#line 34 "../src/utils.vala"
	_data_->_source_object_ = source_object;
#line 34 "../src/utils.vala"
	_data_->_res_ = _res_;
#line 34 "../src/utils.vala"
	enigma_utils_display_open_dialog_co (_data_);
#line 211 "utils.c"
}

static gboolean
enigma_utils_display_open_dialog_co (EnigmaUtilsDisplayOpenDialogData* _data_)
{
#line 22 "../src/utils.vala"
	switch (_data_->_state_) {
#line 22 "../src/utils.vala"
		case 0:
#line 221 "utils.c"
		goto _state_0;
#line 22 "../src/utils.vala"
		case 1:
#line 225 "utils.c"
		goto _state_1;
		default:
#line 22 "../src/utils.vala"
		g_assert_not_reached ();
#line 230 "utils.c"
	}
	_state_0:
#line 23 "../src/utils.vala"
	_data_->_tmp0_ = enigma_utils_win;
#line 23 "../src/utils.vala"
	_data_->_tmp1_ = gtk_file_chooser_native_new (NULL, (GtkWindow*) _data_->_tmp0_, GTK_FILE_CHOOSER_ACTION_OPEN, NULL, NULL);
#line 23 "../src/utils.vala"
	_data_->dialog = _data_->_tmp1_;
#line 24 "../src/utils.vala"
	_data_->_tmp2_ = _data_->dialog;
#line 24 "../src/utils.vala"
	_data_->_tmp3_ = enigma_utils_win;
#line 24 "../src/utils.vala"
	gtk_native_dialog_set_transient_for ((GtkNativeDialog*) _data_->_tmp2_, (GtkWindow*) _data_->_tmp3_);
#line 25 "../src/utils.vala"
	_data_->_tmp4_ = gtk_file_filter_new ();
#line 25 "../src/utils.vala"
	_data_->filter1 = _data_->_tmp4_;
#line 26 "../src/utils.vala"
	_data_->_tmp5_ = _data_->filter1;
#line 26 "../src/utils.vala"
	gtk_file_filter_set_name (_data_->_tmp5_, _ ("Text files"));
#line 27 "../src/utils.vala"
	_data_->_tmp6_ = _data_->filter1;
#line 27 "../src/utils.vala"
	gtk_file_filter_add_pattern (_data_->_tmp6_, "*.txt");
#line 28 "../src/utils.vala"
	_data_->_tmp7_ = _data_->dialog;
#line 28 "../src/utils.vala"
	_data_->_tmp8_ = _data_->filter1;
#line 28 "../src/utils.vala"
	gtk_file_chooser_add_filter ((GtkFileChooser*) _data_->_tmp7_, _data_->_tmp8_);
#line 29 "../src/utils.vala"
	_data_->_tmp9_ = gtk_file_filter_new ();
#line 29 "../src/utils.vala"
	_data_->filter = _data_->_tmp9_;
#line 30 "../src/utils.vala"
	_data_->_tmp10_ = _data_->filter;
#line 30 "../src/utils.vala"
	gtk_file_filter_set_name (_data_->_tmp10_, _ ("All files"));
#line 31 "../src/utils.vala"
	_data_->_tmp11_ = _data_->filter;
#line 31 "../src/utils.vala"
	gtk_file_filter_add_pattern (_data_->_tmp11_, "*");
#line 32 "../src/utils.vala"
	_data_->_tmp12_ = _data_->dialog;
#line 32 "../src/utils.vala"
	_data_->_tmp13_ = _data_->filter;
#line 32 "../src/utils.vala"
	gtk_file_chooser_add_filter ((GtkFileChooser*) _data_->_tmp12_, _data_->_tmp13_);
#line 34 "../src/utils.vala"
	_data_->_tmp14_ = _data_->dialog;
#line 34 "../src/utils.vala"
	_data_->_state_ = 1;
#line 34 "../src/utils.vala"
	enigma_utils_run_dialog_async (_data_->_tmp14_, enigma_utils_display_open_dialog_ready, _data_);
#line 34 "../src/utils.vala"
	return FALSE;
#line 289 "utils.c"
	_state_1:
#line 34 "../src/utils.vala"
	_data_->response = enigma_utils_run_dialog_finish (_data_->_res_);
#line 36 "../src/utils.vala"
	if (_data_->response == GTK_RESPONSE_ACCEPT) {
#line 37 "../src/utils.vala"
		_data_->_tmp15_ = _data_->dialog;
#line 37 "../src/utils.vala"
		_data_->_tmp16_ = gtk_file_chooser_get_file ((GtkFileChooser*) _data_->_tmp15_);
#line 37 "../src/utils.vala"
		_data_->result = _data_->_tmp16_;
#line 37 "../src/utils.vala"
		_g_object_unref0 (_data_->filter);
#line 37 "../src/utils.vala"
		_g_object_unref0 (_data_->filter1);
#line 37 "../src/utils.vala"
		_g_object_unref0 (_data_->dialog);
#line 37 "../src/utils.vala"
		g_task_return_pointer (_data_->_async_result, _data_, NULL);
#line 37 "../src/utils.vala"
		if (_data_->_state_ != 0) {
#line 37 "../src/utils.vala"
			while (!g_task_get_completed (_data_->_async_result)) {
#line 37 "../src/utils.vala"
				g_main_context_iteration (g_task_get_context (_data_->_async_result), TRUE);
#line 315 "utils.c"
			}
		}
#line 37 "../src/utils.vala"
		g_object_unref (_data_->_async_result);
#line 37 "../src/utils.vala"
		return FALSE;
#line 322 "utils.c"
	}
#line 40 "../src/utils.vala"
	_data_->result = NULL;
#line 40 "../src/utils.vala"
	_g_object_unref0 (_data_->filter);
#line 40 "../src/utils.vala"
	_g_object_unref0 (_data_->filter1);
#line 40 "../src/utils.vala"
	_g_object_unref0 (_data_->dialog);
#line 40 "../src/utils.vala"
	g_task_return_pointer (_data_->_async_result, _data_, NULL);
#line 40 "../src/utils.vala"
	if (_data_->_state_ != 0) {
#line 40 "../src/utils.vala"
		while (!g_task_get_completed (_data_->_async_result)) {
#line 40 "../src/utils.vala"
			g_main_context_iteration (g_task_get_context (_data_->_async_result), TRUE);
#line 340 "utils.c"
		}
	}
#line 40 "../src/utils.vala"
	g_object_unref (_data_->_async_result);
#line 40 "../src/utils.vala"
	return FALSE;
#line 347 "utils.c"
}

static void
enigma_utils_display_save_dialog_data_free (gpointer _data)
{
	EnigmaUtilsDisplaySaveDialogData* _data_;
	_data_ = _data;
	_g_object_unref0 (_data_->result);
	g_slice_free (EnigmaUtilsDisplaySaveDialogData, _data_);
}

void
enigma_utils_display_save_dialog (GAsyncReadyCallback _callback_,
                                  gpointer _user_data_)
{
	EnigmaUtilsDisplaySaveDialogData* _data_;
	_data_ = g_slice_new0 (EnigmaUtilsDisplaySaveDialogData);
	_data_->_async_result = g_task_new (NULL, NULL, _callback_, _user_data_);
	g_task_set_task_data (_data_->_async_result, _data_, enigma_utils_display_save_dialog_data_free);
	enigma_utils_display_save_dialog_co (_data_);
}

GFile*
enigma_utils_display_save_dialog_finish (GAsyncResult* _res_)
{
	GFile* result;
	EnigmaUtilsDisplaySaveDialogData* _data_;
	_data_ = g_task_propagate_pointer (G_TASK (_res_), NULL);
	result = _data_->result;
	_data_->result = NULL;
	return result;
}

static void
enigma_utils_display_save_dialog_ready (GObject* source_object,
                                        GAsyncResult* _res_,
                                        gpointer _user_data_)
{
	EnigmaUtilsDisplaySaveDialogData* _data_;
#line 55 "../src/utils.vala"
	_data_ = _user_data_;
#line 55 "../src/utils.vala"
	_data_->_source_object_ = source_object;
#line 55 "../src/utils.vala"
	_data_->_res_ = _res_;
#line 55 "../src/utils.vala"
	enigma_utils_display_save_dialog_co (_data_);
#line 395 "utils.c"
}

static gboolean
enigma_utils_display_save_dialog_co (EnigmaUtilsDisplaySaveDialogData* _data_)
{
#line 43 "../src/utils.vala"
	switch (_data_->_state_) {
#line 43 "../src/utils.vala"
		case 0:
#line 405 "utils.c"
		goto _state_0;
#line 43 "../src/utils.vala"
		case 1:
#line 409 "utils.c"
		goto _state_1;
		default:
#line 43 "../src/utils.vala"
		g_assert_not_reached ();
#line 414 "utils.c"
	}
	_state_0:
#line 44 "../src/utils.vala"
	_data_->_tmp0_ = enigma_utils_win;
#line 44 "../src/utils.vala"
	_data_->_tmp1_ = gtk_file_chooser_native_new (NULL, (GtkWindow*) _data_->_tmp0_, GTK_FILE_CHOOSER_ACTION_SAVE, NULL, NULL);
#line 44 "../src/utils.vala"
	_data_->dialog = _data_->_tmp1_;
#line 45 "../src/utils.vala"
	_data_->_tmp2_ = _data_->dialog;
#line 45 "../src/utils.vala"
	_data_->_tmp3_ = enigma_utils_win;
#line 45 "../src/utils.vala"
	gtk_native_dialog_set_transient_for ((GtkNativeDialog*) _data_->_tmp2_, (GtkWindow*) _data_->_tmp3_);
#line 46 "../src/utils.vala"
	_data_->_tmp4_ = gtk_file_filter_new ();
#line 46 "../src/utils.vala"
	_data_->filter1 = _data_->_tmp4_;
#line 47 "../src/utils.vala"
	_data_->_tmp5_ = _data_->filter1;
#line 47 "../src/utils.vala"
	gtk_file_filter_set_name (_data_->_tmp5_, _ ("Text files"));
#line 48 "../src/utils.vala"
	_data_->_tmp6_ = _data_->filter1;
#line 48 "../src/utils.vala"
	gtk_file_filter_add_pattern (_data_->_tmp6_, "*.txt");
#line 49 "../src/utils.vala"
	_data_->_tmp7_ = _data_->dialog;
#line 49 "../src/utils.vala"
	_data_->_tmp8_ = _data_->filter1;
#line 49 "../src/utils.vala"
	gtk_file_chooser_add_filter ((GtkFileChooser*) _data_->_tmp7_, _data_->_tmp8_);
#line 50 "../src/utils.vala"
	_data_->_tmp9_ = gtk_file_filter_new ();
#line 50 "../src/utils.vala"
	_data_->filter = _data_->_tmp9_;
#line 51 "../src/utils.vala"
	_data_->_tmp10_ = _data_->filter;
#line 51 "../src/utils.vala"
	gtk_file_filter_set_name (_data_->_tmp10_, _ ("All files"));
#line 52 "../src/utils.vala"
	_data_->_tmp11_ = _data_->filter;
#line 52 "../src/utils.vala"
	gtk_file_filter_add_pattern (_data_->_tmp11_, "*");
#line 53 "../src/utils.vala"
	_data_->_tmp12_ = _data_->dialog;
#line 53 "../src/utils.vala"
	_data_->_tmp13_ = _data_->filter;
#line 53 "../src/utils.vala"
	gtk_file_chooser_add_filter ((GtkFileChooser*) _data_->_tmp12_, _data_->_tmp13_);
#line 55 "../src/utils.vala"
	_data_->_tmp14_ = _data_->dialog;
#line 55 "../src/utils.vala"
	_data_->_state_ = 1;
#line 55 "../src/utils.vala"
	enigma_utils_run_dialog_async (_data_->_tmp14_, enigma_utils_display_save_dialog_ready, _data_);
#line 55 "../src/utils.vala"
	return FALSE;
#line 473 "utils.c"
	_state_1:
#line 55 "../src/utils.vala"
	_data_->response = enigma_utils_run_dialog_finish (_data_->_res_);
#line 57 "../src/utils.vala"
	if (_data_->response == GTK_RESPONSE_ACCEPT) {
#line 58 "../src/utils.vala"
		_data_->_tmp15_ = _data_->dialog;
#line 58 "../src/utils.vala"
		_data_->_tmp16_ = gtk_file_chooser_get_file ((GtkFileChooser*) _data_->_tmp15_);
#line 58 "../src/utils.vala"
		_data_->result = _data_->_tmp16_;
#line 58 "../src/utils.vala"
		_g_object_unref0 (_data_->filter);
#line 58 "../src/utils.vala"
		_g_object_unref0 (_data_->filter1);
#line 58 "../src/utils.vala"
		_g_object_unref0 (_data_->dialog);
#line 58 "../src/utils.vala"
		g_task_return_pointer (_data_->_async_result, _data_, NULL);
#line 58 "../src/utils.vala"
		if (_data_->_state_ != 0) {
#line 58 "../src/utils.vala"
			while (!g_task_get_completed (_data_->_async_result)) {
#line 58 "../src/utils.vala"
				g_main_context_iteration (g_task_get_context (_data_->_async_result), TRUE);
#line 499 "utils.c"
			}
		}
#line 58 "../src/utils.vala"
		g_object_unref (_data_->_async_result);
#line 58 "../src/utils.vala"
		return FALSE;
#line 506 "utils.c"
	}
#line 61 "../src/utils.vala"
	_data_->result = NULL;
#line 61 "../src/utils.vala"
	_g_object_unref0 (_data_->filter);
#line 61 "../src/utils.vala"
	_g_object_unref0 (_data_->filter1);
#line 61 "../src/utils.vala"
	_g_object_unref0 (_data_->dialog);
#line 61 "../src/utils.vala"
	g_task_return_pointer (_data_->_async_result, _data_, NULL);
#line 61 "../src/utils.vala"
	if (_data_->_state_ != 0) {
#line 61 "../src/utils.vala"
		while (!g_task_get_completed (_data_->_async_result)) {
#line 61 "../src/utils.vala"
			g_main_context_iteration (g_task_get_context (_data_->_async_result), TRUE);
#line 524 "utils.c"
		}
	}
#line 61 "../src/utils.vala"
	g_object_unref (_data_->_async_result);
#line 61 "../src/utils.vala"
	return FALSE;
#line 531 "utils.c"
}

static void
enigma_utils_run_dialog_async_data_free (gpointer _data)
{
	EnigmaUtilsRunDialogAsyncData* _data_;
	_data_ = _data;
	_g_object_unref0 (_data_->dialog);
	g_slice_free (EnigmaUtilsRunDialogAsyncData, _data_);
}

static gpointer
_g_object_ref0 (gpointer self)
{
	return self ? g_object_ref (self) : NULL;
}

void
enigma_utils_run_dialog_async (GtkFileChooserNative* dialog,
                               GAsyncReadyCallback _callback_,
                               gpointer _user_data_)
{
	EnigmaUtilsRunDialogAsyncData* _data_;
	GtkFileChooserNative* _tmp0_;
	g_return_if_fail (dialog != NULL);
	_data_ = g_slice_new0 (EnigmaUtilsRunDialogAsyncData);
	_data_->_async_result = g_task_new (NULL, NULL, _callback_, _user_data_);
	g_task_set_task_data (_data_->_async_result, _data_, enigma_utils_run_dialog_async_data_free);
	_tmp0_ = _g_object_ref0 (dialog);
	_g_object_unref0 (_data_->dialog);
	_data_->dialog = _tmp0_;
	enigma_utils_run_dialog_async_co (_data_);
}

GtkResponseType
enigma_utils_run_dialog_finish (GAsyncResult* _res_)
{
	GtkResponseType result;
	EnigmaUtilsRunDialogAsyncData* _data_;
	_data_ = g_task_propagate_pointer (G_TASK (_res_), NULL);
	result = _data_->result;
	return result;
}

static Block2Data*
block2_data_ref (Block2Data* _data2_)
{
#line 64 "../src/utils.vala"
	g_atomic_int_inc (&_data2_->_ref_count_);
#line 64 "../src/utils.vala"
	return _data2_;
#line 583 "utils.c"
}

static void
block2_data_unref (void * _userdata_)
{
	Block2Data* _data2_;
	_data2_ = (Block2Data*) _userdata_;
#line 64 "../src/utils.vala"
	if (g_atomic_int_dec_and_test (&_data2_->_ref_count_)) {
#line 64 "../src/utils.vala"
		g_slice_free (Block2Data, _data2_);
#line 595 "utils.c"
	}
}

static void
__lambda8_ (Block2Data* _data2_,
            gint r)
{
#line 68 "../src/utils.vala"
	_data2_->response = (GtkResponseType) r;
#line 70 "../src/utils.vala"
	enigma_utils_run_dialog_async_co (_data2_->_async_data_);
#line 607 "utils.c"
}

static void
___lambda8__gtk_native_dialog_response (GtkNativeDialog* _sender,
                                        gint response_id,
                                        gpointer self)
{
#line 67 "../src/utils.vala"
	__lambda8_ (self, response_id);
#line 617 "utils.c"
}

static gboolean
enigma_utils_run_dialog_async_co (EnigmaUtilsRunDialogAsyncData* _data_)
{
#line 64 "../src/utils.vala"
	switch (_data_->_state_) {
#line 64 "../src/utils.vala"
		case 0:
#line 627 "utils.c"
		goto _state_0;
#line 64 "../src/utils.vala"
		case 1:
#line 631 "utils.c"
		goto _state_1;
		default:
#line 64 "../src/utils.vala"
		g_assert_not_reached ();
#line 636 "utils.c"
	}
	_state_0:
#line 64 "../src/utils.vala"
	_data_->_data2_ = g_slice_new0 (Block2Data);
#line 64 "../src/utils.vala"
	_data_->_data2_->_ref_count_ = 1;
#line 64 "../src/utils.vala"
	_data_->_data2_->_async_data_ = _data_;
#line 65 "../src/utils.vala"
	_data_->_data2_->response = GTK_RESPONSE_CANCEL;
#line 67 "../src/utils.vala"
	g_signal_connect_data ((GtkNativeDialog*) _data_->dialog, "response", (GCallback) ___lambda8__gtk_native_dialog_response, block2_data_ref (_data_->_data2_), (GClosureNotify) block2_data_unref, 0);
#line 73 "../src/utils.vala"
	gtk_native_dialog_show ((GtkNativeDialog*) _data_->dialog);
#line 75 "../src/utils.vala"
	_data_->_state_ = 1;
#line 75 "../src/utils.vala"
	return FALSE;
#line 655 "utils.c"
	_state_1:
	;
#line 76 "../src/utils.vala"
	_data_->result = _data_->_data2_->response;
#line 76 "../src/utils.vala"
	block2_data_unref (_data_->_data2_);
#line 76 "../src/utils.vala"
	_data_->_data2_ = NULL;
#line 76 "../src/utils.vala"
	g_task_return_pointer (_data_->_async_result, _data_, NULL);
#line 76 "../src/utils.vala"
	if (_data_->_state_ != 0) {
#line 76 "../src/utils.vala"
		while (!g_task_get_completed (_data_->_async_result)) {
#line 76 "../src/utils.vala"
			g_main_context_iteration (g_task_get_context (_data_->_async_result), TRUE);
#line 672 "utils.c"
		}
	}
#line 76 "../src/utils.vala"
	g_object_unref (_data_->_async_result);
#line 76 "../src/utils.vala"
	return FALSE;
#line 679 "utils.c"
}

